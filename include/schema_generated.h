// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_FB_NAV_MSGS_H_
#define FLATBUFFERS_GENERATED_SCHEMA_FB_NAV_MSGS_H_

#include "flatbuffers/flatbuffers.h"

namespace fb {

struct MsgMetadata;
struct MsgMetadataBuilder;
struct MsgMetadataT;

struct MsgWithMetadata;
struct MsgWithMetadataBuilder;
struct MsgWithMetadataT;

struct RosTime;

struct RosDuration;

namespace std_msgs {

struct String;
struct StringBuilder;
struct StringT;

}  // namespace std_msgs

namespace amrl_msgs {

struct RobofleetStatus;
struct RobofleetStatusBuilder;
struct RobofleetStatusT;

struct RobofleetSubscription;
struct RobofleetSubscriptionBuilder;
struct RobofleetSubscriptionT;

}  // namespace amrl_msgs

namespace std_msgs {

struct Header;
struct HeaderBuilder;
struct HeaderT;

}  // namespace std_msgs

namespace amrl_msgs {

struct Pose2Df;
struct Pose2DfBuilder;
struct Pose2DfT;

struct Localization2DMsg;
struct Localization2DMsgBuilder;
struct Localization2DMsgT;

struct PathVisualization;
struct PathVisualizationBuilder;
struct PathVisualizationT;

struct Point2D;
struct Point2DBuilder;
struct Point2DT;

struct ColoredPoint2D;
struct ColoredPoint2DBuilder;
struct ColoredPoint2DT;

struct ColoredLine2D;
struct ColoredLine2DBuilder;
struct ColoredLine2DT;

struct ColoredArc2D;
struct ColoredArc2DBuilder;
struct ColoredArc2DT;

struct VisualizationMsg;
struct VisualizationMsgBuilder;
struct VisualizationMsgT;

}  // namespace amrl_msgs

namespace sensor_msgs {

struct NavSatStatus;
struct NavSatStatusBuilder;
struct NavSatStatusT;

struct NavSatFix;
struct NavSatFixBuilder;
struct NavSatFixT;

struct LaserScan;
struct LaserScanBuilder;
struct LaserScanT;

struct CompressedImage;
struct CompressedImageBuilder;
struct CompressedImageT;

struct PointField;
struct PointFieldBuilder;
struct PointFieldT;

struct PointCloud2;
struct PointCloud2Builder;
struct PointCloud2T;

}  // namespace sensor_msgs

namespace geometry_msgs {

struct Point;
struct PointBuilder;
struct PointT;

struct Quaternion;
struct QuaternionBuilder;
struct QuaternionT;

struct Pose;
struct PoseBuilder;
struct PoseT;

struct PoseStamped;
struct PoseStampedBuilder;
struct PoseStampedT;

struct PoseWithCovariance;
struct PoseWithCovarianceBuilder;
struct PoseWithCovarianceT;

struct Vector3;
struct Vector3Builder;
struct Vector3T;

struct Twist;
struct TwistBuilder;
struct TwistT;

struct TwistWithCovariance;
struct TwistWithCovarianceBuilder;
struct TwistWithCovarianceT;

}  // namespace geometry_msgs

namespace nav_msgs {

struct Odometry;
struct OdometryBuilder;
struct OdometryT;

}  // namespace nav_msgs

namespace amrl_msgs {
namespace RobofleetSubscriptionConstants {

enum action_unsubscribe {
  action_unsubscribe_value = 0,
  action_unsubscribe_MIN = action_unsubscribe_value,
  action_unsubscribe_MAX = action_unsubscribe_value
};

inline const action_unsubscribe (&EnumValuesaction_unsubscribe())[1] {
  static const action_unsubscribe values[] = {
    action_unsubscribe_value
  };
  return values;
}

inline const char * const *EnumNamesaction_unsubscribe() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameaction_unsubscribe(action_unsubscribe e) {
  if (flatbuffers::IsOutRange(e, action_unsubscribe_value, action_unsubscribe_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesaction_unsubscribe()[index];
}

enum action_subscribe {
  action_subscribe_value = 1,
  action_subscribe_MIN = action_subscribe_value,
  action_subscribe_MAX = action_subscribe_value
};

inline const action_subscribe (&EnumValuesaction_subscribe())[1] {
  static const action_subscribe values[] = {
    action_subscribe_value
  };
  return values;
}

inline const char * const *EnumNamesaction_subscribe() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameaction_subscribe(action_subscribe e) {
  if (flatbuffers::IsOutRange(e, action_subscribe_value, action_subscribe_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(action_subscribe_value);
  return EnumNamesaction_subscribe()[index];
}

}  // namespace RobofleetSubscriptionConstants
}  // namespace amrl_msgs

namespace sensor_msgs {
namespace NavSatStatusConstants {

enum status_no_fix {
  status_no_fix_value = -1,
  status_no_fix_MIN = status_no_fix_value,
  status_no_fix_MAX = status_no_fix_value
};

inline const status_no_fix (&EnumValuesstatus_no_fix())[1] {
  static const status_no_fix values[] = {
    status_no_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_no_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_no_fix(status_no_fix e) {
  if (flatbuffers::IsOutRange(e, status_no_fix_value, status_no_fix_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(status_no_fix_value);
  return EnumNamesstatus_no_fix()[index];
}

enum status_fix {
  status_fix_value = 0,
  status_fix_MIN = status_fix_value,
  status_fix_MAX = status_fix_value
};

inline const status_fix (&EnumValuesstatus_fix())[1] {
  static const status_fix values[] = {
    status_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_fix(status_fix e) {
  if (flatbuffers::IsOutRange(e, status_fix_value, status_fix_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesstatus_fix()[index];
}

enum status_sbas_fix {
  status_sbas_fix_value = 1,
  status_sbas_fix_MIN = status_sbas_fix_value,
  status_sbas_fix_MAX = status_sbas_fix_value
};

inline const status_sbas_fix (&EnumValuesstatus_sbas_fix())[1] {
  static const status_sbas_fix values[] = {
    status_sbas_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_sbas_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_sbas_fix(status_sbas_fix e) {
  if (flatbuffers::IsOutRange(e, status_sbas_fix_value, status_sbas_fix_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(status_sbas_fix_value);
  return EnumNamesstatus_sbas_fix()[index];
}

enum status_gbas_fix {
  status_gbas_fix_value = 2,
  status_gbas_fix_MIN = status_gbas_fix_value,
  status_gbas_fix_MAX = status_gbas_fix_value
};

inline const status_gbas_fix (&EnumValuesstatus_gbas_fix())[1] {
  static const status_gbas_fix values[] = {
    status_gbas_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_gbas_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_gbas_fix(status_gbas_fix e) {
  if (flatbuffers::IsOutRange(e, status_gbas_fix_value, status_gbas_fix_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(status_gbas_fix_value);
  return EnumNamesstatus_gbas_fix()[index];
}

enum service_gps {
  service_gps_value = 1,
  service_gps_MIN = service_gps_value,
  service_gps_MAX = service_gps_value
};

inline const service_gps (&EnumValuesservice_gps())[1] {
  static const service_gps values[] = {
    service_gps_value
  };
  return values;
}

inline const char * const *EnumNamesservice_gps() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_gps(service_gps e) {
  if (flatbuffers::IsOutRange(e, service_gps_value, service_gps_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_gps_value);
  return EnumNamesservice_gps()[index];
}

enum service_glonass {
  service_glonass_value = 2,
  service_glonass_MIN = service_glonass_value,
  service_glonass_MAX = service_glonass_value
};

inline const service_glonass (&EnumValuesservice_glonass())[1] {
  static const service_glonass values[] = {
    service_glonass_value
  };
  return values;
}

inline const char * const *EnumNamesservice_glonass() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_glonass(service_glonass e) {
  if (flatbuffers::IsOutRange(e, service_glonass_value, service_glonass_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_glonass_value);
  return EnumNamesservice_glonass()[index];
}

enum service_compass {
  service_compass_value = 4,
  service_compass_MIN = service_compass_value,
  service_compass_MAX = service_compass_value
};

inline const service_compass (&EnumValuesservice_compass())[1] {
  static const service_compass values[] = {
    service_compass_value
  };
  return values;
}

inline const char * const *EnumNamesservice_compass() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_compass(service_compass e) {
  if (flatbuffers::IsOutRange(e, service_compass_value, service_compass_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_compass_value);
  return EnumNamesservice_compass()[index];
}

enum service_galileo {
  service_galileo_value = 8,
  service_galileo_MIN = service_galileo_value,
  service_galileo_MAX = service_galileo_value
};

inline const service_galileo (&EnumValuesservice_galileo())[1] {
  static const service_galileo values[] = {
    service_galileo_value
  };
  return values;
}

inline const char * const *EnumNamesservice_galileo() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_galileo(service_galileo e) {
  if (flatbuffers::IsOutRange(e, service_galileo_value, service_galileo_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_galileo_value);
  return EnumNamesservice_galileo()[index];
}

}  // namespace NavSatStatusConstants

namespace NavSatFixConstants {

enum covariance_type_unknown {
  covariance_type_unknown_value = 0,
  covariance_type_unknown_MIN = covariance_type_unknown_value,
  covariance_type_unknown_MAX = covariance_type_unknown_value
};

inline const covariance_type_unknown (&EnumValuescovariance_type_unknown())[1] {
  static const covariance_type_unknown values[] = {
    covariance_type_unknown_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_unknown() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_unknown(covariance_type_unknown e) {
  if (flatbuffers::IsOutRange(e, covariance_type_unknown_value, covariance_type_unknown_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamescovariance_type_unknown()[index];
}

enum covariance_type_approximated {
  covariance_type_approximated_value = 1,
  covariance_type_approximated_MIN = covariance_type_approximated_value,
  covariance_type_approximated_MAX = covariance_type_approximated_value
};

inline const covariance_type_approximated (&EnumValuescovariance_type_approximated())[1] {
  static const covariance_type_approximated values[] = {
    covariance_type_approximated_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_approximated() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_approximated(covariance_type_approximated e) {
  if (flatbuffers::IsOutRange(e, covariance_type_approximated_value, covariance_type_approximated_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(covariance_type_approximated_value);
  return EnumNamescovariance_type_approximated()[index];
}

enum covariance_type_diagonal_known {
  covariance_type_diagonal_known_value = 2,
  covariance_type_diagonal_known_MIN = covariance_type_diagonal_known_value,
  covariance_type_diagonal_known_MAX = covariance_type_diagonal_known_value
};

inline const covariance_type_diagonal_known (&EnumValuescovariance_type_diagonal_known())[1] {
  static const covariance_type_diagonal_known values[] = {
    covariance_type_diagonal_known_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_diagonal_known() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_diagonal_known(covariance_type_diagonal_known e) {
  if (flatbuffers::IsOutRange(e, covariance_type_diagonal_known_value, covariance_type_diagonal_known_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(covariance_type_diagonal_known_value);
  return EnumNamescovariance_type_diagonal_known()[index];
}

enum covariance_type_known {
  covariance_type_known_value = 3,
  covariance_type_known_MIN = covariance_type_known_value,
  covariance_type_known_MAX = covariance_type_known_value
};

inline const covariance_type_known (&EnumValuescovariance_type_known())[1] {
  static const covariance_type_known values[] = {
    covariance_type_known_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_known() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_known(covariance_type_known e) {
  if (flatbuffers::IsOutRange(e, covariance_type_known_value, covariance_type_known_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(covariance_type_known_value);
  return EnumNamescovariance_type_known()[index];
}

}  // namespace NavSatFixConstants

namespace PointFieldConstants {

enum int8 {
  int8_value = 1,
  int8_MIN = int8_value,
  int8_MAX = int8_value
};

inline const int8 (&EnumValuesint8())[1] {
  static const int8 values[] = {
    int8_value
  };
  return values;
}

inline const char * const *EnumNamesint8() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameint8(int8 e) {
  if (flatbuffers::IsOutRange(e, int8_value, int8_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(int8_value);
  return EnumNamesint8()[index];
}

enum uint8 {
  uint8_value = 2,
  uint8_MIN = uint8_value,
  uint8_MAX = uint8_value
};

inline const uint8 (&EnumValuesuint8())[1] {
  static const uint8 values[] = {
    uint8_value
  };
  return values;
}

inline const char * const *EnumNamesuint8() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameuint8(uint8 e) {
  if (flatbuffers::IsOutRange(e, uint8_value, uint8_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(uint8_value);
  return EnumNamesuint8()[index];
}

enum int16 {
  int16_value = 3,
  int16_MIN = int16_value,
  int16_MAX = int16_value
};

inline const int16 (&EnumValuesint16())[1] {
  static const int16 values[] = {
    int16_value
  };
  return values;
}

inline const char * const *EnumNamesint16() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameint16(int16 e) {
  if (flatbuffers::IsOutRange(e, int16_value, int16_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(int16_value);
  return EnumNamesint16()[index];
}

enum uint16 {
  uint16_value = 4,
  uint16_MIN = uint16_value,
  uint16_MAX = uint16_value
};

inline const uint16 (&EnumValuesuint16())[1] {
  static const uint16 values[] = {
    uint16_value
  };
  return values;
}

inline const char * const *EnumNamesuint16() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameuint16(uint16 e) {
  if (flatbuffers::IsOutRange(e, uint16_value, uint16_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(uint16_value);
  return EnumNamesuint16()[index];
}

enum int32 {
  int32_value = 5,
  int32_MIN = int32_value,
  int32_MAX = int32_value
};

inline const int32 (&EnumValuesint32())[1] {
  static const int32 values[] = {
    int32_value
  };
  return values;
}

inline const char * const *EnumNamesint32() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameint32(int32 e) {
  if (flatbuffers::IsOutRange(e, int32_value, int32_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(int32_value);
  return EnumNamesint32()[index];
}

enum uint32 {
  uint32_value = 6,
  uint32_MIN = uint32_value,
  uint32_MAX = uint32_value
};

inline const uint32 (&EnumValuesuint32())[1] {
  static const uint32 values[] = {
    uint32_value
  };
  return values;
}

inline const char * const *EnumNamesuint32() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameuint32(uint32 e) {
  if (flatbuffers::IsOutRange(e, uint32_value, uint32_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(uint32_value);
  return EnumNamesuint32()[index];
}

enum float32 {
  float32_value = 7,
  float32_MIN = float32_value,
  float32_MAX = float32_value
};

inline const float32 (&EnumValuesfloat32())[1] {
  static const float32 values[] = {
    float32_value
  };
  return values;
}

inline const char * const *EnumNamesfloat32() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamefloat32(float32 e) {
  if (flatbuffers::IsOutRange(e, float32_value, float32_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(float32_value);
  return EnumNamesfloat32()[index];
}

enum float64 {
  float64_value = 8,
  float64_MIN = float64_value,
  float64_MAX = float64_value
};

inline const float64 (&EnumValuesfloat64())[1] {
  static const float64 values[] = {
    float64_value
  };
  return values;
}

inline const char * const *EnumNamesfloat64() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamefloat64(float64 e) {
  if (flatbuffers::IsOutRange(e, float64_value, float64_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(float64_value);
  return EnumNamesfloat64()[index];
}

}  // namespace PointFieldConstants
}  // namespace sensor_msgs

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RosTime FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t secs_;
  uint32_t nsecs_;

 public:
  RosTime()
      : secs_(0),
        nsecs_(0) {
  }
  RosTime(uint32_t _secs, uint32_t _nsecs)
      : secs_(flatbuffers::EndianScalar(_secs)),
        nsecs_(flatbuffers::EndianScalar(_nsecs)) {
  }
  uint32_t secs() const {
    return flatbuffers::EndianScalar(secs_);
  }
  uint32_t nsecs() const {
    return flatbuffers::EndianScalar(nsecs_);
  }
};
FLATBUFFERS_STRUCT_END(RosTime, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RosDuration FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t secs_;
  int32_t nsecs_;

 public:
  RosDuration()
      : secs_(0),
        nsecs_(0) {
  }
  RosDuration(int32_t _secs, int32_t _nsecs)
      : secs_(flatbuffers::EndianScalar(_secs)),
        nsecs_(flatbuffers::EndianScalar(_nsecs)) {
  }
  int32_t secs() const {
    return flatbuffers::EndianScalar(secs_);
  }
  int32_t nsecs() const {
    return flatbuffers::EndianScalar(nsecs_);
  }
};
FLATBUFFERS_STRUCT_END(RosDuration, 8);

struct MsgMetadataT : public flatbuffers::NativeTable {
  typedef MsgMetadata TableType;
  std::string type;
  std::string topic;
  MsgMetadataT() {
  }
};

struct MsgMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgMetadataT NativeTableType;
  typedef MsgMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TOPIC = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *topic() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyString(topic()) &&
           verifier.EndTable();
  }
  MsgMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgMetadataBuilder {
  typedef MsgMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(MsgMetadata::VT_TYPE, type);
  }
  void add_topic(flatbuffers::Offset<flatbuffers::String> topic) {
    fbb_.AddOffset(MsgMetadata::VT_TOPIC, topic);
  }
  explicit MsgMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> topic = 0) {
  MsgMetadataBuilder builder_(_fbb);
  builder_.add_topic(topic);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgMetadata> CreateMsgMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *topic = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto topic__ = topic ? _fbb.CreateString(topic) : 0;
  return fb::CreateMsgMetadata(
      _fbb,
      type__,
      topic__);
}

flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgWithMetadataT : public flatbuffers::NativeTable {
  typedef MsgWithMetadata TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  MsgWithMetadataT() {
  }
};

struct MsgWithMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgWithMetadataT NativeTableType;
  typedef MsgWithMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  MsgWithMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgWithMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgWithMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgWithMetadataBuilder {
  typedef MsgWithMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MsgWithMetadata::VT___METADATA, __metadata);
  }
  explicit MsgWithMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgWithMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgWithMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  MsgWithMetadataBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace std_msgs {

struct StringT : public flatbuffers::NativeTable {
  typedef String TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string data;
  StringT() {
  }
};

struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringT NativeTableType;
  typedef StringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
  StringT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StringT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<String> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StringBuilder {
  typedef String Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(String::VT___METADATA, __metadata);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(String::VT_DATA, data);
  }
  explicit StringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<String>(end);
    fbb_.Required(o, String::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<String> CreateString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<String> CreateStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *data = nullptr) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return fb::std_msgs::CreateString(
      _fbb,
      __metadata,
      data__);
}

flatbuffers::Offset<String> CreateString(flatbuffers::FlatBufferBuilder &_fbb, const StringT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace std_msgs

namespace amrl_msgs {

struct RobofleetStatusT : public flatbuffers::NativeTable {
  typedef RobofleetStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string status;
  bool is_ok;
  float battery_level;
  std::string location;
  RobofleetStatusT()
      : is_ok(false),
        battery_level(0.0f) {
  }
};

struct RobofleetStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RobofleetStatusT NativeTableType;
  typedef RobofleetStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STATUS = 6,
    VT_IS_OK = 8,
    VT_BATTERY_LEVEL = 10,
    VT_LOCATION = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *status() const {
    return GetPointer<const flatbuffers::String *>(VT_STATUS);
  }
  bool is_ok() const {
    return GetField<uint8_t>(VT_IS_OK, 0) != 0;
  }
  float battery_level() const {
    return GetField<float>(VT_BATTERY_LEVEL, 0.0f);
  }
  const flatbuffers::String *location() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyField<uint8_t>(verifier, VT_IS_OK) &&
           VerifyField<float>(verifier, VT_BATTERY_LEVEL) &&
           VerifyOffsetRequired(verifier, VT_LOCATION) &&
           verifier.VerifyString(location()) &&
           verifier.EndTable();
  }
  RobofleetStatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RobofleetStatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RobofleetStatus> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RobofleetStatusBuilder {
  typedef RobofleetStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RobofleetStatus::VT___METADATA, __metadata);
  }
  void add_status(flatbuffers::Offset<flatbuffers::String> status) {
    fbb_.AddOffset(RobofleetStatus::VT_STATUS, status);
  }
  void add_is_ok(bool is_ok) {
    fbb_.AddElement<uint8_t>(RobofleetStatus::VT_IS_OK, static_cast<uint8_t>(is_ok), 0);
  }
  void add_battery_level(float battery_level) {
    fbb_.AddElement<float>(RobofleetStatus::VT_BATTERY_LEVEL, battery_level, 0.0f);
  }
  void add_location(flatbuffers::Offset<flatbuffers::String> location) {
    fbb_.AddOffset(RobofleetStatus::VT_LOCATION, location);
  }
  explicit RobofleetStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RobofleetStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RobofleetStatus>(end);
    fbb_.Required(o, RobofleetStatus::VT_STATUS);
    fbb_.Required(o, RobofleetStatus::VT_LOCATION);
    return o;
  }
};

inline flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> status = 0,
    bool is_ok = false,
    float battery_level = 0.0f,
    flatbuffers::Offset<flatbuffers::String> location = 0) {
  RobofleetStatusBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_battery_level(battery_level);
  builder_.add_status(status);
  builder_.add___metadata(__metadata);
  builder_.add_is_ok(is_ok);
  return builder_.Finish();
}

inline flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *status = nullptr,
    bool is_ok = false,
    float battery_level = 0.0f,
    const char *location = nullptr) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  auto location__ = location ? _fbb.CreateString(location) : 0;
  return fb::amrl_msgs::CreateRobofleetStatus(
      _fbb,
      __metadata,
      status__,
      is_ok,
      battery_level,
      location__);
}

flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RobofleetSubscriptionT : public flatbuffers::NativeTable {
  typedef RobofleetSubscription TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string topic_regex;
  uint8_t action;
  RobofleetSubscriptionT()
      : action(0) {
  }
};

struct RobofleetSubscription FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RobofleetSubscriptionT NativeTableType;
  typedef RobofleetSubscriptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TOPIC_REGEX = 6,
    VT_ACTION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *topic_regex() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPIC_REGEX);
  }
  uint8_t action() const {
    return GetField<uint8_t>(VT_ACTION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TOPIC_REGEX) &&
           verifier.VerifyString(topic_regex()) &&
           VerifyField<uint8_t>(verifier, VT_ACTION) &&
           verifier.EndTable();
  }
  RobofleetSubscriptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RobofleetSubscriptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RobofleetSubscription> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetSubscriptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RobofleetSubscriptionBuilder {
  typedef RobofleetSubscription Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RobofleetSubscription::VT___METADATA, __metadata);
  }
  void add_topic_regex(flatbuffers::Offset<flatbuffers::String> topic_regex) {
    fbb_.AddOffset(RobofleetSubscription::VT_TOPIC_REGEX, topic_regex);
  }
  void add_action(uint8_t action) {
    fbb_.AddElement<uint8_t>(RobofleetSubscription::VT_ACTION, action, 0);
  }
  explicit RobofleetSubscriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RobofleetSubscription> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RobofleetSubscription>(end);
    fbb_.Required(o, RobofleetSubscription::VT_TOPIC_REGEX);
    return o;
  }
};

inline flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscription(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> topic_regex = 0,
    uint8_t action = 0) {
  RobofleetSubscriptionBuilder builder_(_fbb);
  builder_.add_topic_regex(topic_regex);
  builder_.add___metadata(__metadata);
  builder_.add_action(action);
  return builder_.Finish();
}

inline flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *topic_regex = nullptr,
    uint8_t action = 0) {
  auto topic_regex__ = topic_regex ? _fbb.CreateString(topic_regex) : 0;
  return fb::amrl_msgs::CreateRobofleetSubscription(
      _fbb,
      __metadata,
      topic_regex__,
      action);
}

flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscription(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetSubscriptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace amrl_msgs

namespace std_msgs {

struct HeaderT : public flatbuffers::NativeTable {
  typedef Header TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  uint32_t seq;
  std::unique_ptr<fb::RosTime> stamp;
  std::string frame_id;
  HeaderT()
      : seq(0) {
  }
};

struct Header FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeaderT NativeTableType;
  typedef HeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SEQ = 6,
    VT_STAMP = 8,
    VT_FRAME_ID = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint32_t seq() const {
    return GetField<uint32_t>(VT_SEQ, 0);
  }
  const fb::RosTime *stamp() const {
    return GetStruct<const fb::RosTime *>(VT_STAMP);
  }
  const flatbuffers::String *frame_id() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAME_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint32_t>(verifier, VT_SEQ) &&
           VerifyFieldRequired<fb::RosTime>(verifier, VT_STAMP) &&
           VerifyOffsetRequired(verifier, VT_FRAME_ID) &&
           verifier.VerifyString(frame_id()) &&
           verifier.EndTable();
  }
  HeaderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeaderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Header> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeaderBuilder {
  typedef Header Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Header::VT___METADATA, __metadata);
  }
  void add_seq(uint32_t seq) {
    fbb_.AddElement<uint32_t>(Header::VT_SEQ, seq, 0);
  }
  void add_stamp(const fb::RosTime *stamp) {
    fbb_.AddStruct(Header::VT_STAMP, stamp);
  }
  void add_frame_id(flatbuffers::Offset<flatbuffers::String> frame_id) {
    fbb_.AddOffset(Header::VT_FRAME_ID, frame_id);
  }
  explicit HeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Header>(end);
    fbb_.Required(o, Header::VT_STAMP);
    fbb_.Required(o, Header::VT_FRAME_ID);
    return o;
  }
};

inline flatbuffers::Offset<Header> CreateHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t seq = 0,
    const fb::RosTime *stamp = 0,
    flatbuffers::Offset<flatbuffers::String> frame_id = 0) {
  HeaderBuilder builder_(_fbb);
  builder_.add_frame_id(frame_id);
  builder_.add_stamp(stamp);
  builder_.add_seq(seq);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Header> CreateHeaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t seq = 0,
    const fb::RosTime *stamp = 0,
    const char *frame_id = nullptr) {
  auto frame_id__ = frame_id ? _fbb.CreateString(frame_id) : 0;
  return fb::std_msgs::CreateHeader(
      _fbb,
      __metadata,
      seq,
      stamp,
      frame_id__);
}

flatbuffers::Offset<Header> CreateHeader(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace std_msgs

namespace amrl_msgs {

struct Pose2DfT : public flatbuffers::NativeTable {
  typedef Pose2Df TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  float x;
  float y;
  float theta;
  Pose2DfT()
      : x(0.0f),
        y(0.0f),
        theta(0.0f) {
  }
};

struct Pose2Df FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pose2DfT NativeTableType;
  typedef Pose2DfBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_THETA = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float theta() const {
    return GetField<float>(VT_THETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           VerifyField<float>(verifier, VT_THETA) &&
           verifier.EndTable();
  }
  Pose2DfT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pose2DfT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pose2Df> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pose2DfT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pose2DfBuilder {
  typedef Pose2Df Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Pose2Df::VT___METADATA, __metadata);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(Pose2Df::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Pose2Df::VT_Y, y, 0.0f);
  }
  void add_theta(float theta) {
    fbb_.AddElement<float>(Pose2Df::VT_THETA, theta, 0.0f);
  }
  explicit Pose2DfBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pose2Df> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pose2Df>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pose2Df> CreatePose2Df(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float x = 0.0f,
    float y = 0.0f,
    float theta = 0.0f) {
  Pose2DfBuilder builder_(_fbb);
  builder_.add_theta(theta);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Pose2Df> CreatePose2Df(flatbuffers::FlatBufferBuilder &_fbb, const Pose2DfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Localization2DMsgT : public flatbuffers::NativeTable {
  typedef Localization2DMsg TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::unique_ptr<fb::amrl_msgs::Pose2DfT> pose;
  std::string map;
  Localization2DMsgT() {
  }
};

struct Localization2DMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Localization2DMsgT NativeTableType;
  typedef Localization2DMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8,
    VT_MAP = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::amrl_msgs::Pose2Df *pose() const {
    return GetPointer<const fb::amrl_msgs::Pose2Df *>(VT_POSE);
  }
  const flatbuffers::String *map() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_MAP) &&
           verifier.VerifyString(map()) &&
           verifier.EndTable();
  }
  Localization2DMsgT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Localization2DMsgT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Localization2DMsg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Localization2DMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Localization2DMsgBuilder {
  typedef Localization2DMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Localization2DMsg::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Localization2DMsg::VT_HEADER, header);
  }
  void add_pose(flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose) {
    fbb_.AddOffset(Localization2DMsg::VT_POSE, pose);
  }
  void add_map(flatbuffers::Offset<flatbuffers::String> map) {
    fbb_.AddOffset(Localization2DMsg::VT_MAP, map);
  }
  explicit Localization2DMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Localization2DMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Localization2DMsg>(end);
    fbb_.Required(o, Localization2DMsg::VT_HEADER);
    fbb_.Required(o, Localization2DMsg::VT_POSE);
    fbb_.Required(o, Localization2DMsg::VT_MAP);
    return o;
  }
};

inline flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose = 0,
    flatbuffers::Offset<flatbuffers::String> map = 0) {
  Localization2DMsgBuilder builder_(_fbb);
  builder_.add_map(map);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose = 0,
    const char *map = nullptr) {
  auto map__ = map ? _fbb.CreateString(map) : 0;
  return fb::amrl_msgs::CreateLocalization2DMsg(
      _fbb,
      __metadata,
      header,
      pose,
      map__);
}

flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsg(flatbuffers::FlatBufferBuilder &_fbb, const Localization2DMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PathVisualizationT : public flatbuffers::NativeTable {
  typedef PathVisualization TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  float curvature;
  float distance;
  float clearance;
  PathVisualizationT()
      : curvature(0.0f),
        distance(0.0f),
        clearance(0.0f) {
  }
};

struct PathVisualization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PathVisualizationT NativeTableType;
  typedef PathVisualizationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_CURVATURE = 6,
    VT_DISTANCE = 8,
    VT_CLEARANCE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float curvature() const {
    return GetField<float>(VT_CURVATURE, 0.0f);
  }
  float distance() const {
    return GetField<float>(VT_DISTANCE, 0.0f);
  }
  float clearance() const {
    return GetField<float>(VT_CLEARANCE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_CURVATURE) &&
           VerifyField<float>(verifier, VT_DISTANCE) &&
           VerifyField<float>(verifier, VT_CLEARANCE) &&
           verifier.EndTable();
  }
  PathVisualizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PathVisualizationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PathVisualization> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PathVisualizationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PathVisualizationBuilder {
  typedef PathVisualization Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PathVisualization::VT___METADATA, __metadata);
  }
  void add_curvature(float curvature) {
    fbb_.AddElement<float>(PathVisualization::VT_CURVATURE, curvature, 0.0f);
  }
  void add_distance(float distance) {
    fbb_.AddElement<float>(PathVisualization::VT_DISTANCE, distance, 0.0f);
  }
  void add_clearance(float clearance) {
    fbb_.AddElement<float>(PathVisualization::VT_CLEARANCE, clearance, 0.0f);
  }
  explicit PathVisualizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PathVisualization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PathVisualization>(end);
    return o;
  }
};

inline flatbuffers::Offset<PathVisualization> CreatePathVisualization(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float curvature = 0.0f,
    float distance = 0.0f,
    float clearance = 0.0f) {
  PathVisualizationBuilder builder_(_fbb);
  builder_.add_clearance(clearance);
  builder_.add_distance(distance);
  builder_.add_curvature(curvature);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<PathVisualization> CreatePathVisualization(flatbuffers::FlatBufferBuilder &_fbb, const PathVisualizationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Point2DT : public flatbuffers::NativeTable {
  typedef Point2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  float x;
  float y;
  Point2DT()
      : x(0.0f),
        y(0.0f) {
  }
};

struct Point2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Point2DT NativeTableType;
  typedef Point2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           verifier.EndTable();
  }
  Point2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Point2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Point2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Point2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Point2DBuilder {
  typedef Point2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Point2D::VT___METADATA, __metadata);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(Point2D::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Point2D::VT_Y, y, 0.0f);
  }
  explicit Point2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Point2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Point2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Point2D> CreatePoint2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float x = 0.0f,
    float y = 0.0f) {
  Point2DBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Point2D> CreatePoint2D(flatbuffers::FlatBufferBuilder &_fbb, const Point2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ColoredPoint2DT : public flatbuffers::NativeTable {
  typedef ColoredPoint2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::amrl_msgs::Point2DT> point;
  uint32_t color;
  ColoredPoint2DT()
      : color(0) {
  }
};

struct ColoredPoint2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ColoredPoint2DT NativeTableType;
  typedef ColoredPoint2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POINT = 6,
    VT_COLOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::amrl_msgs::Point2D *point() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_POINT);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POINT) &&
           verifier.VerifyTable(point()) &&
           VerifyField<uint32_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
  ColoredPoint2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ColoredPoint2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ColoredPoint2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ColoredPoint2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ColoredPoint2DBuilder {
  typedef ColoredPoint2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColoredPoint2D::VT___METADATA, __metadata);
  }
  void add_point(flatbuffers::Offset<fb::amrl_msgs::Point2D> point) {
    fbb_.AddOffset(ColoredPoint2D::VT_POINT, point);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(ColoredPoint2D::VT_COLOR, color, 0);
  }
  explicit ColoredPoint2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ColoredPoint2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColoredPoint2D>(end);
    fbb_.Required(o, ColoredPoint2D::VT_POINT);
    return o;
  }
};

inline flatbuffers::Offset<ColoredPoint2D> CreateColoredPoint2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::amrl_msgs::Point2D> point = 0,
    uint32_t color = 0) {
  ColoredPoint2DBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_point(point);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<ColoredPoint2D> CreateColoredPoint2D(flatbuffers::FlatBufferBuilder &_fbb, const ColoredPoint2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ColoredLine2DT : public flatbuffers::NativeTable {
  typedef ColoredLine2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::amrl_msgs::Point2DT> p0;
  std::unique_ptr<fb::amrl_msgs::Point2DT> p1;
  uint32_t color;
  ColoredLine2DT()
      : color(0) {
  }
};

struct ColoredLine2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ColoredLine2DT NativeTableType;
  typedef ColoredLine2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_P0 = 6,
    VT_P1 = 8,
    VT_COLOR = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::amrl_msgs::Point2D *p0() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_P0);
  }
  const fb::amrl_msgs::Point2D *p1() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_P1);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_P0) &&
           verifier.VerifyTable(p0()) &&
           VerifyOffsetRequired(verifier, VT_P1) &&
           verifier.VerifyTable(p1()) &&
           VerifyField<uint32_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
  ColoredLine2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ColoredLine2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ColoredLine2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ColoredLine2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ColoredLine2DBuilder {
  typedef ColoredLine2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColoredLine2D::VT___METADATA, __metadata);
  }
  void add_p0(flatbuffers::Offset<fb::amrl_msgs::Point2D> p0) {
    fbb_.AddOffset(ColoredLine2D::VT_P0, p0);
  }
  void add_p1(flatbuffers::Offset<fb::amrl_msgs::Point2D> p1) {
    fbb_.AddOffset(ColoredLine2D::VT_P1, p1);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(ColoredLine2D::VT_COLOR, color, 0);
  }
  explicit ColoredLine2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ColoredLine2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColoredLine2D>(end);
    fbb_.Required(o, ColoredLine2D::VT_P0);
    fbb_.Required(o, ColoredLine2D::VT_P1);
    return o;
  }
};

inline flatbuffers::Offset<ColoredLine2D> CreateColoredLine2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::amrl_msgs::Point2D> p0 = 0,
    flatbuffers::Offset<fb::amrl_msgs::Point2D> p1 = 0,
    uint32_t color = 0) {
  ColoredLine2DBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_p1(p1);
  builder_.add_p0(p0);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<ColoredLine2D> CreateColoredLine2D(flatbuffers::FlatBufferBuilder &_fbb, const ColoredLine2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ColoredArc2DT : public flatbuffers::NativeTable {
  typedef ColoredArc2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::amrl_msgs::Point2DT> center;
  float radius;
  float start_angle;
  float end_angle;
  uint32_t color;
  ColoredArc2DT()
      : radius(0.0f),
        start_angle(0.0f),
        end_angle(0.0f),
        color(0) {
  }
};

struct ColoredArc2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ColoredArc2DT NativeTableType;
  typedef ColoredArc2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_CENTER = 6,
    VT_RADIUS = 8,
    VT_START_ANGLE = 10,
    VT_END_ANGLE = 12,
    VT_COLOR = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::amrl_msgs::Point2D *center() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  float start_angle() const {
    return GetField<float>(VT_START_ANGLE, 0.0f);
  }
  float end_angle() const {
    return GetField<float>(VT_END_ANGLE, 0.0f);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_CENTER) &&
           verifier.VerifyTable(center()) &&
           VerifyField<float>(verifier, VT_RADIUS) &&
           VerifyField<float>(verifier, VT_START_ANGLE) &&
           VerifyField<float>(verifier, VT_END_ANGLE) &&
           VerifyField<uint32_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
  ColoredArc2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ColoredArc2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ColoredArc2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ColoredArc2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ColoredArc2DBuilder {
  typedef ColoredArc2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColoredArc2D::VT___METADATA, __metadata);
  }
  void add_center(flatbuffers::Offset<fb::amrl_msgs::Point2D> center) {
    fbb_.AddOffset(ColoredArc2D::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(ColoredArc2D::VT_RADIUS, radius, 0.0f);
  }
  void add_start_angle(float start_angle) {
    fbb_.AddElement<float>(ColoredArc2D::VT_START_ANGLE, start_angle, 0.0f);
  }
  void add_end_angle(float end_angle) {
    fbb_.AddElement<float>(ColoredArc2D::VT_END_ANGLE, end_angle, 0.0f);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(ColoredArc2D::VT_COLOR, color, 0);
  }
  explicit ColoredArc2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ColoredArc2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColoredArc2D>(end);
    fbb_.Required(o, ColoredArc2D::VT_CENTER);
    return o;
  }
};

inline flatbuffers::Offset<ColoredArc2D> CreateColoredArc2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::amrl_msgs::Point2D> center = 0,
    float radius = 0.0f,
    float start_angle = 0.0f,
    float end_angle = 0.0f,
    uint32_t color = 0) {
  ColoredArc2DBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_end_angle(end_angle);
  builder_.add_start_angle(start_angle);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<ColoredArc2D> CreateColoredArc2D(flatbuffers::FlatBufferBuilder &_fbb, const ColoredArc2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VisualizationMsgT : public flatbuffers::NativeTable {
  typedef VisualizationMsg TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::string ns;
  std::vector<std::unique_ptr<fb::amrl_msgs::Pose2DfT>> particles;
  std::vector<std::unique_ptr<fb::amrl_msgs::PathVisualizationT>> path_options;
  std::vector<std::unique_ptr<fb::amrl_msgs::ColoredPoint2DT>> points;
  std::vector<std::unique_ptr<fb::amrl_msgs::ColoredLine2DT>> lines;
  std::vector<std::unique_ptr<fb::amrl_msgs::ColoredArc2DT>> arcs;
  VisualizationMsgT() {
  }
};

struct VisualizationMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VisualizationMsgT NativeTableType;
  typedef VisualizationMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_NS = 8,
    VT_PARTICLES = 10,
    VT_PATH_OPTIONS = 12,
    VT_POINTS = 14,
    VT_LINES = 16,
    VT_ARCS = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *ns() const {
    return GetPointer<const flatbuffers::String *>(VT_NS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *particles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *>(VT_PARTICLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> *path_options() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> *>(VT_PATH_OPTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> *points() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> *>(VT_POINTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> *lines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> *>(VT_LINES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> *arcs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> *>(VT_ARCS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           VerifyOffsetRequired(verifier, VT_PARTICLES) &&
           verifier.VerifyVector(particles()) &&
           verifier.VerifyVectorOfTables(particles()) &&
           VerifyOffsetRequired(verifier, VT_PATH_OPTIONS) &&
           verifier.VerifyVector(path_options()) &&
           verifier.VerifyVectorOfTables(path_options()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffsetRequired(verifier, VT_LINES) &&
           verifier.VerifyVector(lines()) &&
           verifier.VerifyVectorOfTables(lines()) &&
           VerifyOffsetRequired(verifier, VT_ARCS) &&
           verifier.VerifyVector(arcs()) &&
           verifier.VerifyVectorOfTables(arcs()) &&
           verifier.EndTable();
  }
  VisualizationMsgT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VisualizationMsgT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VisualizationMsg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VisualizationMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VisualizationMsgBuilder {
  typedef VisualizationMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(VisualizationMsg::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(VisualizationMsg::VT_HEADER, header);
  }
  void add_ns(flatbuffers::Offset<flatbuffers::String> ns) {
    fbb_.AddOffset(VisualizationMsg::VT_NS, ns);
  }
  void add_particles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> particles) {
    fbb_.AddOffset(VisualizationMsg::VT_PARTICLES, particles);
  }
  void add_path_options(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>>> path_options) {
    fbb_.AddOffset(VisualizationMsg::VT_PATH_OPTIONS, path_options);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>>> points) {
    fbb_.AddOffset(VisualizationMsg::VT_POINTS, points);
  }
  void add_lines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>>> lines) {
    fbb_.AddOffset(VisualizationMsg::VT_LINES, lines);
  }
  void add_arcs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>>> arcs) {
    fbb_.AddOffset(VisualizationMsg::VT_ARCS, arcs);
  }
  explicit VisualizationMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VisualizationMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VisualizationMsg>(end);
    fbb_.Required(o, VisualizationMsg::VT_HEADER);
    fbb_.Required(o, VisualizationMsg::VT_NS);
    fbb_.Required(o, VisualizationMsg::VT_PARTICLES);
    fbb_.Required(o, VisualizationMsg::VT_PATH_OPTIONS);
    fbb_.Required(o, VisualizationMsg::VT_POINTS);
    fbb_.Required(o, VisualizationMsg::VT_LINES);
    fbb_.Required(o, VisualizationMsg::VT_ARCS);
    return o;
  }
};

inline flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> ns = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> particles = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>>> path_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>>> points = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>>> lines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>>> arcs = 0) {
  VisualizationMsgBuilder builder_(_fbb);
  builder_.add_arcs(arcs);
  builder_.add_lines(lines);
  builder_.add_points(points);
  builder_.add_path_options(path_options);
  builder_.add_particles(particles);
  builder_.add_ns(ns);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *ns = nullptr,
    const std::vector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *particles = nullptr,
    const std::vector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> *path_options = nullptr,
    const std::vector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> *points = nullptr,
    const std::vector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> *lines = nullptr,
    const std::vector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> *arcs = nullptr) {
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  auto particles__ = particles ? _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>(*particles) : 0;
  auto path_options__ = path_options ? _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>>(*path_options) : 0;
  auto points__ = points ? _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>>(*points) : 0;
  auto lines__ = lines ? _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>>(*lines) : 0;
  auto arcs__ = arcs ? _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>>(*arcs) : 0;
  return fb::amrl_msgs::CreateVisualizationMsg(
      _fbb,
      __metadata,
      header,
      ns__,
      particles__,
      path_options__,
      points__,
      lines__,
      arcs__);
}

flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsg(flatbuffers::FlatBufferBuilder &_fbb, const VisualizationMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace amrl_msgs

namespace sensor_msgs {

struct NavSatStatusT : public flatbuffers::NativeTable {
  typedef NavSatStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  int8_t status;
  uint16_t service;
  NavSatStatusT()
      : status(0),
        service(0) {
  }
};

struct NavSatStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NavSatStatusT NativeTableType;
  typedef NavSatStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STATUS = 6,
    VT_SERVICE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  int8_t status() const {
    return GetField<int8_t>(VT_STATUS, 0);
  }
  uint16_t service() const {
    return GetField<uint16_t>(VT_SERVICE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyField<uint16_t>(verifier, VT_SERVICE) &&
           verifier.EndTable();
  }
  NavSatStatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NavSatStatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NavSatStatus> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NavSatStatusBuilder {
  typedef NavSatStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NavSatStatus::VT___METADATA, __metadata);
  }
  void add_status(int8_t status) {
    fbb_.AddElement<int8_t>(NavSatStatus::VT_STATUS, status, 0);
  }
  void add_service(uint16_t service) {
    fbb_.AddElement<uint16_t>(NavSatStatus::VT_SERVICE, service, 0);
  }
  explicit NavSatStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NavSatStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NavSatStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    int8_t status = 0,
    uint16_t service = 0) {
  NavSatStatusBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_service(service);
  builder_.add_status(status);
  return builder_.Finish();
}

flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NavSatFixT : public flatbuffers::NativeTable {
  typedef NavSatFix TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::unique_ptr<fb::sensor_msgs::NavSatStatusT> status;
  double latitude;
  double longitude;
  double altitude;
  std::vector<double> position_covariance;
  uint8_t position_covariance_type;
  NavSatFixT()
      : latitude(0.0),
        longitude(0.0),
        altitude(0.0),
        position_covariance_type(0) {
  }
};

struct NavSatFix FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NavSatFixT NativeTableType;
  typedef NavSatFixBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_STATUS = 8,
    VT_LATITUDE = 10,
    VT_LONGITUDE = 12,
    VT_ALTITUDE = 14,
    VT_POSITION_COVARIANCE = 16,
    VT_POSITION_COVARIANCE_TYPE = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::sensor_msgs::NavSatStatus *status() const {
    return GetPointer<const fb::sensor_msgs::NavSatStatus *>(VT_STATUS);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  double longitude() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  double altitude() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  const flatbuffers::Vector<double> *position_covariance() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POSITION_COVARIANCE);
  }
  uint8_t position_covariance_type() const {
    return GetField<uint8_t>(VT_POSITION_COVARIANCE_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyField<double>(verifier, VT_LATITUDE) &&
           VerifyField<double>(verifier, VT_LONGITUDE) &&
           VerifyField<double>(verifier, VT_ALTITUDE) &&
           VerifyOffsetRequired(verifier, VT_POSITION_COVARIANCE) &&
           verifier.VerifyVector(position_covariance()) &&
           VerifyField<uint8_t>(verifier, VT_POSITION_COVARIANCE_TYPE) &&
           verifier.EndTable();
  }
  NavSatFixT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NavSatFixT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NavSatFix> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NavSatFixBuilder {
  typedef NavSatFix Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NavSatFix::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(NavSatFix::VT_HEADER, header);
  }
  void add_status(flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status) {
    fbb_.AddOffset(NavSatFix::VT_STATUS, status);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(NavSatFix::VT_LATITUDE, latitude, 0.0);
  }
  void add_longitude(double longitude) {
    fbb_.AddElement<double>(NavSatFix::VT_LONGITUDE, longitude, 0.0);
  }
  void add_altitude(double altitude) {
    fbb_.AddElement<double>(NavSatFix::VT_ALTITUDE, altitude, 0.0);
  }
  void add_position_covariance(flatbuffers::Offset<flatbuffers::Vector<double>> position_covariance) {
    fbb_.AddOffset(NavSatFix::VT_POSITION_COVARIANCE, position_covariance);
  }
  void add_position_covariance_type(uint8_t position_covariance_type) {
    fbb_.AddElement<uint8_t>(NavSatFix::VT_POSITION_COVARIANCE_TYPE, position_covariance_type, 0);
  }
  explicit NavSatFixBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NavSatFix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NavSatFix>(end);
    fbb_.Required(o, NavSatFix::VT_HEADER);
    fbb_.Required(o, NavSatFix::VT_STATUS);
    fbb_.Required(o, NavSatFix::VT_POSITION_COVARIANCE);
    return o;
  }
};

inline flatbuffers::Offset<NavSatFix> CreateNavSatFix(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> position_covariance = 0,
    uint8_t position_covariance_type = 0) {
  NavSatFixBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  builder_.add_position_covariance(position_covariance);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_position_covariance_type(position_covariance_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NavSatFix> CreateNavSatFixDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0,
    const std::vector<double> *position_covariance = nullptr,
    uint8_t position_covariance_type = 0) {
  auto position_covariance__ = position_covariance ? _fbb.CreateVector<double>(*position_covariance) : 0;
  return fb::sensor_msgs::CreateNavSatFix(
      _fbb,
      __metadata,
      header,
      status,
      latitude,
      longitude,
      altitude,
      position_covariance__,
      position_covariance_type);
}

flatbuffers::Offset<NavSatFix> CreateNavSatFix(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaserScanT : public flatbuffers::NativeTable {
  typedef LaserScan TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  float angle_min;
  float angle_max;
  float angle_increment;
  float time_increment;
  float scan_time;
  float range_min;
  float range_max;
  std::vector<float> ranges;
  std::vector<float> intensities;
  LaserScanT()
      : angle_min(0.0f),
        angle_max(0.0f),
        angle_increment(0.0f),
        time_increment(0.0f),
        scan_time(0.0f),
        range_min(0.0f),
        range_max(0.0f) {
  }
};

struct LaserScan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaserScanT NativeTableType;
  typedef LaserScanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_ANGLE_MIN = 8,
    VT_ANGLE_MAX = 10,
    VT_ANGLE_INCREMENT = 12,
    VT_TIME_INCREMENT = 14,
    VT_SCAN_TIME = 16,
    VT_RANGE_MIN = 18,
    VT_RANGE_MAX = 20,
    VT_RANGES = 22,
    VT_INTENSITIES = 24
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  float angle_min() const {
    return GetField<float>(VT_ANGLE_MIN, 0.0f);
  }
  float angle_max() const {
    return GetField<float>(VT_ANGLE_MAX, 0.0f);
  }
  float angle_increment() const {
    return GetField<float>(VT_ANGLE_INCREMENT, 0.0f);
  }
  float time_increment() const {
    return GetField<float>(VT_TIME_INCREMENT, 0.0f);
  }
  float scan_time() const {
    return GetField<float>(VT_SCAN_TIME, 0.0f);
  }
  float range_min() const {
    return GetField<float>(VT_RANGE_MIN, 0.0f);
  }
  float range_max() const {
    return GetField<float>(VT_RANGE_MAX, 0.0f);
  }
  const flatbuffers::Vector<float> *ranges() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_RANGES);
  }
  const flatbuffers::Vector<float> *intensities() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_INTENSITIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<float>(verifier, VT_ANGLE_MIN) &&
           VerifyField<float>(verifier, VT_ANGLE_MAX) &&
           VerifyField<float>(verifier, VT_ANGLE_INCREMENT) &&
           VerifyField<float>(verifier, VT_TIME_INCREMENT) &&
           VerifyField<float>(verifier, VT_SCAN_TIME) &&
           VerifyField<float>(verifier, VT_RANGE_MIN) &&
           VerifyField<float>(verifier, VT_RANGE_MAX) &&
           VerifyOffsetRequired(verifier, VT_RANGES) &&
           verifier.VerifyVector(ranges()) &&
           VerifyOffsetRequired(verifier, VT_INTENSITIES) &&
           verifier.VerifyVector(intensities()) &&
           verifier.EndTable();
  }
  LaserScanT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaserScanT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaserScan> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaserScanT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaserScanBuilder {
  typedef LaserScan Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LaserScan::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(LaserScan::VT_HEADER, header);
  }
  void add_angle_min(float angle_min) {
    fbb_.AddElement<float>(LaserScan::VT_ANGLE_MIN, angle_min, 0.0f);
  }
  void add_angle_max(float angle_max) {
    fbb_.AddElement<float>(LaserScan::VT_ANGLE_MAX, angle_max, 0.0f);
  }
  void add_angle_increment(float angle_increment) {
    fbb_.AddElement<float>(LaserScan::VT_ANGLE_INCREMENT, angle_increment, 0.0f);
  }
  void add_time_increment(float time_increment) {
    fbb_.AddElement<float>(LaserScan::VT_TIME_INCREMENT, time_increment, 0.0f);
  }
  void add_scan_time(float scan_time) {
    fbb_.AddElement<float>(LaserScan::VT_SCAN_TIME, scan_time, 0.0f);
  }
  void add_range_min(float range_min) {
    fbb_.AddElement<float>(LaserScan::VT_RANGE_MIN, range_min, 0.0f);
  }
  void add_range_max(float range_max) {
    fbb_.AddElement<float>(LaserScan::VT_RANGE_MAX, range_max, 0.0f);
  }
  void add_ranges(flatbuffers::Offset<flatbuffers::Vector<float>> ranges) {
    fbb_.AddOffset(LaserScan::VT_RANGES, ranges);
  }
  void add_intensities(flatbuffers::Offset<flatbuffers::Vector<float>> intensities) {
    fbb_.AddOffset(LaserScan::VT_INTENSITIES, intensities);
  }
  explicit LaserScanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaserScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaserScan>(end);
    fbb_.Required(o, LaserScan::VT_HEADER);
    fbb_.Required(o, LaserScan::VT_RANGES);
    fbb_.Required(o, LaserScan::VT_INTENSITIES);
    return o;
  }
};

inline flatbuffers::Offset<LaserScan> CreateLaserScan(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float angle_min = 0.0f,
    float angle_max = 0.0f,
    float angle_increment = 0.0f,
    float time_increment = 0.0f,
    float scan_time = 0.0f,
    float range_min = 0.0f,
    float range_max = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> ranges = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> intensities = 0) {
  LaserScanBuilder builder_(_fbb);
  builder_.add_intensities(intensities);
  builder_.add_ranges(ranges);
  builder_.add_range_max(range_max);
  builder_.add_range_min(range_min);
  builder_.add_scan_time(scan_time);
  builder_.add_time_increment(time_increment);
  builder_.add_angle_increment(angle_increment);
  builder_.add_angle_max(angle_max);
  builder_.add_angle_min(angle_min);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<LaserScan> CreateLaserScanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float angle_min = 0.0f,
    float angle_max = 0.0f,
    float angle_increment = 0.0f,
    float time_increment = 0.0f,
    float scan_time = 0.0f,
    float range_min = 0.0f,
    float range_max = 0.0f,
    const std::vector<float> *ranges = nullptr,
    const std::vector<float> *intensities = nullptr) {
  auto ranges__ = ranges ? _fbb.CreateVector<float>(*ranges) : 0;
  auto intensities__ = intensities ? _fbb.CreateVector<float>(*intensities) : 0;
  return fb::sensor_msgs::CreateLaserScan(
      _fbb,
      __metadata,
      header,
      angle_min,
      angle_max,
      angle_increment,
      time_increment,
      scan_time,
      range_min,
      range_max,
      ranges__,
      intensities__);
}

flatbuffers::Offset<LaserScan> CreateLaserScan(flatbuffers::FlatBufferBuilder &_fbb, const LaserScanT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CompressedImageT : public flatbuffers::NativeTable {
  typedef CompressedImage TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::string format;
  std::vector<uint8_t> data;
  CompressedImageT() {
  }
};

struct CompressedImage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompressedImageT NativeTableType;
  typedef CompressedImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_FORMAT = 8,
    VT_DATA = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *format() const {
    return GetPointer<const flatbuffers::String *>(VT_FORMAT);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_FORMAT) &&
           verifier.VerifyString(format()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  CompressedImageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CompressedImageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CompressedImage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CompressedImageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CompressedImageBuilder {
  typedef CompressedImage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CompressedImage::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(CompressedImage::VT_HEADER, header);
  }
  void add_format(flatbuffers::Offset<flatbuffers::String> format) {
    fbb_.AddOffset(CompressedImage::VT_FORMAT, format);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(CompressedImage::VT_DATA, data);
  }
  explicit CompressedImageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CompressedImage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompressedImage>(end);
    fbb_.Required(o, CompressedImage::VT_HEADER);
    fbb_.Required(o, CompressedImage::VT_FORMAT);
    fbb_.Required(o, CompressedImage::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<CompressedImage> CreateCompressedImage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> format = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  CompressedImageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_format(format);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompressedImage> CreateCompressedImageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *format = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto format__ = format ? _fbb.CreateString(format) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fb::sensor_msgs::CreateCompressedImage(
      _fbb,
      __metadata,
      header,
      format__,
      data__);
}

flatbuffers::Offset<CompressedImage> CreateCompressedImage(flatbuffers::FlatBufferBuilder &_fbb, const CompressedImageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointFieldT : public flatbuffers::NativeTable {
  typedef PointField TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string name;
  uint32_t offset;
  uint8_t datatype;
  uint32_t count;
  PointFieldT()
      : offset(0),
        datatype(0),
        count(0) {
  }
};

struct PointField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointFieldT NativeTableType;
  typedef PointFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_NAME = 6,
    VT_OFFSET = 8,
    VT_DATATYPE = 10,
    VT_COUNT = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  uint8_t datatype() const {
    return GetField<uint8_t>(VT_DATATYPE, 0);
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET) &&
           VerifyField<uint8_t>(verifier, VT_DATATYPE) &&
           VerifyField<uint32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
  PointFieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointFieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PointField> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointFieldBuilder {
  typedef PointField Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PointField::VT___METADATA, __metadata);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PointField::VT_NAME, name);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(PointField::VT_OFFSET, offset, 0);
  }
  void add_datatype(uint8_t datatype) {
    fbb_.AddElement<uint8_t>(PointField::VT_DATATYPE, datatype, 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(PointField::VT_COUNT, count, 0);
  }
  explicit PointFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PointField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PointField>(end);
    fbb_.Required(o, PointField::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<PointField> CreatePointField(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t offset = 0,
    uint8_t datatype = 0,
    uint32_t count = 0) {
  PointFieldBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_offset(offset);
  builder_.add_name(name);
  builder_.add___metadata(__metadata);
  builder_.add_datatype(datatype);
  return builder_.Finish();
}

inline flatbuffers::Offset<PointField> CreatePointFieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *name = nullptr,
    uint32_t offset = 0,
    uint8_t datatype = 0,
    uint32_t count = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fb::sensor_msgs::CreatePointField(
      _fbb,
      __metadata,
      name__,
      offset,
      datatype,
      count);
}

flatbuffers::Offset<PointField> CreatePointField(flatbuffers::FlatBufferBuilder &_fbb, const PointFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointCloud2T : public flatbuffers::NativeTable {
  typedef PointCloud2 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  uint32_t height;
  uint32_t width;
  std::vector<std::unique_ptr<fb::sensor_msgs::PointFieldT>> fields;
  bool is_bigendian;
  uint32_t point_step;
  uint32_t row_step;
  std::vector<uint8_t> data;
  bool is_dense;
  PointCloud2T()
      : height(0),
        width(0),
        is_bigendian(false),
        point_step(0),
        row_step(0),
        is_dense(false) {
  }
};

struct PointCloud2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointCloud2T NativeTableType;
  typedef PointCloud2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_HEIGHT = 8,
    VT_WIDTH = 10,
    VT_FIELDS = 12,
    VT_IS_BIGENDIAN = 14,
    VT_POINT_STEP = 16,
    VT_ROW_STEP = 18,
    VT_DATA = 20,
    VT_IS_DENSE = 22
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::sensor_msgs::PointField>> *fields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::sensor_msgs::PointField>> *>(VT_FIELDS);
  }
  bool is_bigendian() const {
    return GetField<uint8_t>(VT_IS_BIGENDIAN, 0) != 0;
  }
  uint32_t point_step() const {
    return GetField<uint32_t>(VT_POINT_STEP, 0);
  }
  uint32_t row_step() const {
    return GetField<uint32_t>(VT_ROW_STEP, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool is_dense() const {
    return GetField<uint8_t>(VT_IS_DENSE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyOffsetRequired(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyField<uint8_t>(verifier, VT_IS_BIGENDIAN) &&
           VerifyField<uint32_t>(verifier, VT_POINT_STEP) &&
           VerifyField<uint32_t>(verifier, VT_ROW_STEP) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint8_t>(verifier, VT_IS_DENSE) &&
           verifier.EndTable();
  }
  PointCloud2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointCloud2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PointCloud2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointCloud2T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointCloud2Builder {
  typedef PointCloud2 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PointCloud2::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PointCloud2::VT_HEADER, header);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_HEIGHT, height, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_WIDTH, width, 0);
  }
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::sensor_msgs::PointField>>> fields) {
    fbb_.AddOffset(PointCloud2::VT_FIELDS, fields);
  }
  void add_is_bigendian(bool is_bigendian) {
    fbb_.AddElement<uint8_t>(PointCloud2::VT_IS_BIGENDIAN, static_cast<uint8_t>(is_bigendian), 0);
  }
  void add_point_step(uint32_t point_step) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_POINT_STEP, point_step, 0);
  }
  void add_row_step(uint32_t row_step) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_ROW_STEP, row_step, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(PointCloud2::VT_DATA, data);
  }
  void add_is_dense(bool is_dense) {
    fbb_.AddElement<uint8_t>(PointCloud2::VT_IS_DENSE, static_cast<uint8_t>(is_dense), 0);
  }
  explicit PointCloud2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PointCloud2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PointCloud2>(end);
    fbb_.Required(o, PointCloud2::VT_HEADER);
    fbb_.Required(o, PointCloud2::VT_FIELDS);
    fbb_.Required(o, PointCloud2::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<PointCloud2> CreatePointCloud2(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::sensor_msgs::PointField>>> fields = 0,
    bool is_bigendian = false,
    uint32_t point_step = 0,
    uint32_t row_step = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    bool is_dense = false) {
  PointCloud2Builder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_row_step(row_step);
  builder_.add_point_step(point_step);
  builder_.add_fields(fields);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_is_dense(is_dense);
  builder_.add_is_bigendian(is_bigendian);
  return builder_.Finish();
}

inline flatbuffers::Offset<PointCloud2> CreatePointCloud2Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    const std::vector<flatbuffers::Offset<fb::sensor_msgs::PointField>> *fields = nullptr,
    bool is_bigendian = false,
    uint32_t point_step = 0,
    uint32_t row_step = 0,
    const std::vector<uint8_t> *data = nullptr,
    bool is_dense = false) {
  auto fields__ = fields ? _fbb.CreateVector<flatbuffers::Offset<fb::sensor_msgs::PointField>>(*fields) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fb::sensor_msgs::CreatePointCloud2(
      _fbb,
      __metadata,
      header,
      height,
      width,
      fields__,
      is_bigendian,
      point_step,
      row_step,
      data__,
      is_dense);
}

flatbuffers::Offset<PointCloud2> CreatePointCloud2(flatbuffers::FlatBufferBuilder &_fbb, const PointCloud2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace sensor_msgs

namespace geometry_msgs {

struct PointT : public flatbuffers::NativeTable {
  typedef Point TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  double x;
  double y;
  double z;
  PointT()
      : x(0.0),
        y(0.0),
        z(0.0) {
  }
};

struct Point FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointT NativeTableType;
  typedef PointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
  PointT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Point> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointBuilder {
  typedef Point Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Point::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Point::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Point::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Point::VT_Z, z, 0.0);
  }
  explicit PointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Point> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Point>(end);
    return o;
  }
};

inline flatbuffers::Offset<Point> CreatePoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  PointBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Point> CreatePoint(flatbuffers::FlatBufferBuilder &_fbb, const PointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuaternionT : public flatbuffers::NativeTable {
  typedef Quaternion TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  double x;
  double y;
  double z;
  double w;
  QuaternionT()
      : x(0.0),
        y(0.0),
        z(0.0),
        w(0.0) {
  }
};

struct Quaternion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuaternionT NativeTableType;
  typedef QuaternionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_W = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  double w() const {
    return GetField<double>(VT_W, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           VerifyField<double>(verifier, VT_W) &&
           verifier.EndTable();
  }
  QuaternionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuaternionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Quaternion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuaternionBuilder {
  typedef Quaternion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Quaternion::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Quaternion::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Quaternion::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Quaternion::VT_Z, z, 0.0);
  }
  void add_w(double w) {
    fbb_.AddElement<double>(Quaternion::VT_W, w, 0.0);
  }
  explicit QuaternionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quaternion> CreateQuaternion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0,
    double w = 0.0) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_w(w);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Quaternion> CreateQuaternion(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseT : public flatbuffers::NativeTable {
  typedef Pose TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::PointT> position;
  std::unique_ptr<fb::geometry_msgs::QuaternionT> orientation;
  PoseT() {
  }
};

struct Pose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoseT NativeTableType;
  typedef PoseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSITION = 6,
    VT_ORIENTATION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Point *position() const {
    return GetPointer<const fb::geometry_msgs::Point *>(VT_POSITION);
  }
  const fb::geometry_msgs::Quaternion *orientation() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_ORIENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATION) &&
           verifier.VerifyTable(orientation()) &&
           verifier.EndTable();
  }
  PoseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseBuilder {
  typedef Pose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Pose::VT___METADATA, __metadata);
  }
  void add_position(flatbuffers::Offset<fb::geometry_msgs::Point> position) {
    fbb_.AddOffset(Pose::VT_POSITION, position);
  }
  void add_orientation(flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation) {
    fbb_.AddOffset(Pose::VT_ORIENTATION, orientation);
  }
  explicit PoseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pose>(end);
    fbb_.Required(o, Pose::VT_POSITION);
    fbb_.Required(o, Pose::VT_ORIENTATION);
    return o;
  }
};

inline flatbuffers::Offset<Pose> CreatePose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Point> position = 0,
    flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0) {
  PoseBuilder builder_(_fbb);
  builder_.add_orientation(orientation);
  builder_.add_position(position);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Pose> CreatePose(flatbuffers::FlatBufferBuilder &_fbb, const PoseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseStampedT : public flatbuffers::NativeTable {
  typedef PoseStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::unique_ptr<fb::geometry_msgs::PoseT> pose;
  PoseStampedT() {
  }
};

struct PoseStamped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoseStampedT NativeTableType;
  typedef PoseStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           verifier.EndTable();
  }
  PoseStampedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseStampedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PoseStamped> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseStampedBuilder {
  typedef PoseStamped Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseStamped::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PoseStamped::VT_HEADER, header);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(PoseStamped::VT_POSE, pose);
  }
  explicit PoseStampedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PoseStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PoseStamped>(end);
    fbb_.Required(o, PoseStamped::VT_HEADER);
    fbb_.Required(o, PoseStamped::VT_POSE);
    return o;
  }
};

inline flatbuffers::Offset<PoseStamped> CreatePoseStamped(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0) {
  PoseStampedBuilder builder_(_fbb);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<PoseStamped> CreatePoseStamped(flatbuffers::FlatBufferBuilder &_fbb, const PoseStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseWithCovarianceT : public flatbuffers::NativeTable {
  typedef PoseWithCovariance TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::PoseT> pose;
  std::vector<double> covariance;
  PoseWithCovarianceT() {
  }
};

struct PoseWithCovariance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoseWithCovarianceT NativeTableType;
  typedef PoseWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSE = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  const flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  PoseWithCovarianceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PoseWithCovariance> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseWithCovarianceBuilder {
  typedef PoseWithCovariance Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseWithCovariance::VT___METADATA, __metadata);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(PoseWithCovariance::VT_POSE, pose);
  }
  void add_covariance(flatbuffers::Offset<flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(PoseWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit PoseWithCovarianceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PoseWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PoseWithCovariance>(end);
    fbb_.Required(o, PoseWithCovariance::VT_POSE);
    fbb_.Required(o, PoseWithCovariance::VT_COVARIANCE);
    return o;
  }
};

inline flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> covariance = 0) {
  PoseWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_pose(pose);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovarianceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geometry_msgs::CreatePoseWithCovariance(
      _fbb,
      __metadata,
      pose,
      covariance__);
}

flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Vector3T : public flatbuffers::NativeTable {
  typedef Vector3 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  double x;
  double y;
  double z;
  Vector3T()
      : x(0.0),
        y(0.0),
        z(0.0) {
  }
};

struct Vector3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Vector3T NativeTableType;
  typedef Vector3Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
  Vector3T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Vector3T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Vector3> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Vector3Builder {
  typedef Vector3 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Vector3::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Vector3::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector3::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector3::VT_Z, z, 0.0);
  }
  explicit Vector3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Vector3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector3>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector3> CreateVector3(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  Vector3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Vector3> CreateVector3(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TwistT : public flatbuffers::NativeTable {
  typedef Twist TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::Vector3T> linear;
  std::unique_ptr<fb::geometry_msgs::Vector3T> angular;
  TwistT() {
  }
};

struct Twist FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TwistT NativeTableType;
  typedef TwistBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LINEAR = 6,
    VT_ANGULAR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Vector3 *linear() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_LINEAR);
  }
  const fb::geometry_msgs::Vector3 *angular() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_ANGULAR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LINEAR) &&
           verifier.VerifyTable(linear()) &&
           VerifyOffsetRequired(verifier, VT_ANGULAR) &&
           verifier.VerifyTable(angular()) &&
           verifier.EndTable();
  }
  TwistT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TwistT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Twist> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TwistBuilder {
  typedef Twist Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Twist::VT___METADATA, __metadata);
  }
  void add_linear(flatbuffers::Offset<fb::geometry_msgs::Vector3> linear) {
    fbb_.AddOffset(Twist::VT_LINEAR, linear);
  }
  void add_angular(flatbuffers::Offset<fb::geometry_msgs::Vector3> angular) {
    fbb_.AddOffset(Twist::VT_ANGULAR, angular);
  }
  explicit TwistBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Twist> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Twist>(end);
    fbb_.Required(o, Twist::VT_LINEAR);
    fbb_.Required(o, Twist::VT_ANGULAR);
    return o;
  }
};

inline flatbuffers::Offset<Twist> CreateTwist(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Vector3> linear = 0,
    flatbuffers::Offset<fb::geometry_msgs::Vector3> angular = 0) {
  TwistBuilder builder_(_fbb);
  builder_.add_angular(angular);
  builder_.add_linear(linear);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Twist> CreateTwist(flatbuffers::FlatBufferBuilder &_fbb, const TwistT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TwistWithCovarianceT : public flatbuffers::NativeTable {
  typedef TwistWithCovariance TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::TwistT> twist;
  std::vector<double> covariance;
  TwistWithCovarianceT() {
  }
};

struct TwistWithCovariance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TwistWithCovarianceT NativeTableType;
  typedef TwistWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TWIST = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Twist *twist() const {
    return GetPointer<const fb::geometry_msgs::Twist *>(VT_TWIST);
  }
  const flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  TwistWithCovarianceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TwistWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TwistWithCovariance> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TwistWithCovarianceBuilder {
  typedef TwistWithCovariance Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TwistWithCovariance::VT___METADATA, __metadata);
  }
  void add_twist(flatbuffers::Offset<fb::geometry_msgs::Twist> twist) {
    fbb_.AddOffset(TwistWithCovariance::VT_TWIST, twist);
  }
  void add_covariance(flatbuffers::Offset<flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(TwistWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit TwistWithCovarianceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TwistWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TwistWithCovariance>(end);
    fbb_.Required(o, TwistWithCovariance::VT_TWIST);
    fbb_.Required(o, TwistWithCovariance::VT_COVARIANCE);
    return o;
  }
};

inline flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> covariance = 0) {
  TwistWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_twist(twist);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovarianceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geometry_msgs::CreateTwistWithCovariance(
      _fbb,
      __metadata,
      twist,
      covariance__);
}

flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace geometry_msgs

namespace nav_msgs {

struct OdometryT : public flatbuffers::NativeTable {
  typedef Odometry TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::string child_frame_id;
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT> pose;
  std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT> twist;
  OdometryT() {
  }
};

struct Odometry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OdometryT NativeTableType;
  typedef OdometryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_CHILD_FRAME_ID = 8,
    VT_POSE = 10,
    VT_TWIST = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *child_frame_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CHILD_FRAME_ID);
  }
  const fb::geometry_msgs::PoseWithCovariance *pose() const {
    return GetPointer<const fb::geometry_msgs::PoseWithCovariance *>(VT_POSE);
  }
  const fb::geometry_msgs::TwistWithCovariance *twist() const {
    return GetPointer<const fb::geometry_msgs::TwistWithCovariance *>(VT_TWIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_CHILD_FRAME_ID) &&
           verifier.VerifyString(child_frame_id()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           verifier.EndTable();
  }
  OdometryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OdometryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Odometry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OdometryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OdometryBuilder {
  typedef Odometry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Odometry::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Odometry::VT_HEADER, header);
  }
  void add_child_frame_id(flatbuffers::Offset<flatbuffers::String> child_frame_id) {
    fbb_.AddOffset(Odometry::VT_CHILD_FRAME_ID, child_frame_id);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose) {
    fbb_.AddOffset(Odometry::VT_POSE, pose);
  }
  void add_twist(flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist) {
    fbb_.AddOffset(Odometry::VT_TWIST, twist);
  }
  explicit OdometryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Odometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Odometry>(end);
    fbb_.Required(o, Odometry::VT_HEADER);
    fbb_.Required(o, Odometry::VT_CHILD_FRAME_ID);
    fbb_.Required(o, Odometry::VT_POSE);
    fbb_.Required(o, Odometry::VT_TWIST);
    return o;
  }
};

inline flatbuffers::Offset<Odometry> CreateOdometry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> child_frame_id = 0,
    flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0,
    flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist = 0) {
  OdometryBuilder builder_(_fbb);
  builder_.add_twist(twist);
  builder_.add_pose(pose);
  builder_.add_child_frame_id(child_frame_id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Odometry> CreateOdometryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *child_frame_id = nullptr,
    flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0,
    flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist = 0) {
  auto child_frame_id__ = child_frame_id ? _fbb.CreateString(child_frame_id) : 0;
  return fb::nav_msgs::CreateOdometry(
      _fbb,
      __metadata,
      header,
      child_frame_id__,
      pose,
      twist);
}

flatbuffers::Offset<Odometry> CreateOdometry(flatbuffers::FlatBufferBuilder &_fbb, const OdometryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace nav_msgs

inline MsgMetadataT *MsgMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::MsgMetadataT> _o = std::unique_ptr<fb::MsgMetadataT>(new MsgMetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgMetadata::UnPackTo(MsgMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = topic(); if (_e) _o->topic = _e->str(); }
}

inline flatbuffers::Offset<MsgMetadata> MsgMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _topic = _o->topic.empty() ? 0 : _fbb.CreateString(_o->topic);
  return fb::CreateMsgMetadata(
      _fbb,
      _type,
      _topic);
}

inline MsgWithMetadataT *MsgWithMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::MsgWithMetadataT> _o = std::unique_ptr<fb::MsgWithMetadataT>(new MsgWithMetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgWithMetadata::UnPackTo(MsgWithMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<MsgWithMetadata> MsgWithMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgWithMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgWithMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::CreateMsgWithMetadata(
      _fbb,
      ___metadata);
}

namespace std_msgs {

inline StringT *String::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::std_msgs::StringT> _o = std::unique_ptr<fb::std_msgs::StringT>(new StringT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void String::UnPackTo(StringT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = data(); if (_e) _o->data = _e->str(); }
}

inline flatbuffers::Offset<String> String::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateString(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<String> CreateString(flatbuffers::FlatBufferBuilder &_fbb, const StringT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StringT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _fbb.CreateString(_o->data);
  return fb::std_msgs::CreateString(
      _fbb,
      ___metadata,
      _data);
}

}  // namespace std_msgs

namespace amrl_msgs {

inline RobofleetStatusT *RobofleetStatus::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::RobofleetStatusT> _o = std::unique_ptr<fb::amrl_msgs::RobofleetStatusT>(new RobofleetStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RobofleetStatus::UnPackTo(RobofleetStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = is_ok(); _o->is_ok = _e; }
  { auto _e = battery_level(); _o->battery_level = _e; }
  { auto _e = location(); if (_e) _o->location = _e->str(); }
}

inline flatbuffers::Offset<RobofleetStatus> RobofleetStatus::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRobofleetStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RobofleetStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _status = _fbb.CreateString(_o->status);
  auto _is_ok = _o->is_ok;
  auto _battery_level = _o->battery_level;
  auto _location = _fbb.CreateString(_o->location);
  return fb::amrl_msgs::CreateRobofleetStatus(
      _fbb,
      ___metadata,
      _status,
      _is_ok,
      _battery_level,
      _location);
}

inline RobofleetSubscriptionT *RobofleetSubscription::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::RobofleetSubscriptionT> _o = std::unique_ptr<fb::amrl_msgs::RobofleetSubscriptionT>(new RobofleetSubscriptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RobofleetSubscription::UnPackTo(RobofleetSubscriptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = topic_regex(); if (_e) _o->topic_regex = _e->str(); }
  { auto _e = action(); _o->action = _e; }
}

inline flatbuffers::Offset<RobofleetSubscription> RobofleetSubscription::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetSubscriptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRobofleetSubscription(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscription(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetSubscriptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RobofleetSubscriptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _topic_regex = _fbb.CreateString(_o->topic_regex);
  auto _action = _o->action;
  return fb::amrl_msgs::CreateRobofleetSubscription(
      _fbb,
      ___metadata,
      _topic_regex,
      _action);
}

}  // namespace amrl_msgs

namespace std_msgs {

inline HeaderT *Header::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::std_msgs::HeaderT> _o = std::unique_ptr<fb::std_msgs::HeaderT>(new HeaderT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Header::UnPackTo(HeaderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = seq(); _o->seq = _e; }
  { auto _e = stamp(); if (_e) _o->stamp = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
  { auto _e = frame_id(); if (_e) _o->frame_id = _e->str(); }
}

inline flatbuffers::Offset<Header> Header::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHeader(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Header> CreateHeader(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HeaderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _seq = _o->seq;
  auto _stamp = _o->stamp ? _o->stamp.get() : 0;
  auto _frame_id = _fbb.CreateString(_o->frame_id);
  return fb::std_msgs::CreateHeader(
      _fbb,
      ___metadata,
      _seq,
      _stamp,
      _frame_id);
}

}  // namespace std_msgs

namespace amrl_msgs {

inline Pose2DfT *Pose2Df::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::Pose2DfT> _o = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(new Pose2DfT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pose2Df::UnPackTo(Pose2DfT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = theta(); _o->theta = _e; }
}

inline flatbuffers::Offset<Pose2Df> Pose2Df::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pose2DfT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePose2Df(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pose2Df> CreatePose2Df(flatbuffers::FlatBufferBuilder &_fbb, const Pose2DfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pose2DfT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _theta = _o->theta;
  return fb::amrl_msgs::CreatePose2Df(
      _fbb,
      ___metadata,
      _x,
      _y,
      _theta);
}

inline Localization2DMsgT *Localization2DMsg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::Localization2DMsgT> _o = std::unique_ptr<fb::amrl_msgs::Localization2DMsgT>(new Localization2DMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Localization2DMsg::UnPackTo(Localization2DMsgT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->UnPack(_resolver)); }
  { auto _e = map(); if (_e) _o->map = _e->str(); }
}

inline flatbuffers::Offset<Localization2DMsg> Localization2DMsg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Localization2DMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLocalization2DMsg(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsg(flatbuffers::FlatBufferBuilder &_fbb, const Localization2DMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Localization2DMsgT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose2Df(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _map = _fbb.CreateString(_o->map);
  return fb::amrl_msgs::CreateLocalization2DMsg(
      _fbb,
      ___metadata,
      _header,
      _pose,
      _map);
}

inline PathVisualizationT *PathVisualization::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::PathVisualizationT> _o = std::unique_ptr<fb::amrl_msgs::PathVisualizationT>(new PathVisualizationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PathVisualization::UnPackTo(PathVisualizationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = curvature(); _o->curvature = _e; }
  { auto _e = distance(); _o->distance = _e; }
  { auto _e = clearance(); _o->clearance = _e; }
}

inline flatbuffers::Offset<PathVisualization> PathVisualization::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PathVisualizationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePathVisualization(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PathVisualization> CreatePathVisualization(flatbuffers::FlatBufferBuilder &_fbb, const PathVisualizationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PathVisualizationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _curvature = _o->curvature;
  auto _distance = _o->distance;
  auto _clearance = _o->clearance;
  return fb::amrl_msgs::CreatePathVisualization(
      _fbb,
      ___metadata,
      _curvature,
      _distance,
      _clearance);
}

inline Point2DT *Point2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::Point2DT> _o = std::unique_ptr<fb::amrl_msgs::Point2DT>(new Point2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Point2D::UnPackTo(Point2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
}

inline flatbuffers::Offset<Point2D> Point2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Point2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoint2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Point2D> CreatePoint2D(flatbuffers::FlatBufferBuilder &_fbb, const Point2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Point2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  return fb::amrl_msgs::CreatePoint2D(
      _fbb,
      ___metadata,
      _x,
      _y);
}

inline ColoredPoint2DT *ColoredPoint2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::ColoredPoint2DT> _o = std::unique_ptr<fb::amrl_msgs::ColoredPoint2DT>(new ColoredPoint2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ColoredPoint2D::UnPackTo(ColoredPoint2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = point(); if (_e) _o->point = std::unique_ptr<fb::amrl_msgs::Point2DT>(_e->UnPack(_resolver)); }
  { auto _e = color(); _o->color = _e; }
}

inline flatbuffers::Offset<ColoredPoint2D> ColoredPoint2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ColoredPoint2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateColoredPoint2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ColoredPoint2D> CreateColoredPoint2D(flatbuffers::FlatBufferBuilder &_fbb, const ColoredPoint2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ColoredPoint2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _point = _o->point ? CreatePoint2D(_fbb, _o->point.get(), _rehasher) : 0;
  auto _color = _o->color;
  return fb::amrl_msgs::CreateColoredPoint2D(
      _fbb,
      ___metadata,
      _point,
      _color);
}

inline ColoredLine2DT *ColoredLine2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::ColoredLine2DT> _o = std::unique_ptr<fb::amrl_msgs::ColoredLine2DT>(new ColoredLine2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ColoredLine2D::UnPackTo(ColoredLine2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = p0(); if (_e) _o->p0 = std::unique_ptr<fb::amrl_msgs::Point2DT>(_e->UnPack(_resolver)); }
  { auto _e = p1(); if (_e) _o->p1 = std::unique_ptr<fb::amrl_msgs::Point2DT>(_e->UnPack(_resolver)); }
  { auto _e = color(); _o->color = _e; }
}

inline flatbuffers::Offset<ColoredLine2D> ColoredLine2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ColoredLine2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateColoredLine2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ColoredLine2D> CreateColoredLine2D(flatbuffers::FlatBufferBuilder &_fbb, const ColoredLine2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ColoredLine2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _p0 = _o->p0 ? CreatePoint2D(_fbb, _o->p0.get(), _rehasher) : 0;
  auto _p1 = _o->p1 ? CreatePoint2D(_fbb, _o->p1.get(), _rehasher) : 0;
  auto _color = _o->color;
  return fb::amrl_msgs::CreateColoredLine2D(
      _fbb,
      ___metadata,
      _p0,
      _p1,
      _color);
}

inline ColoredArc2DT *ColoredArc2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::ColoredArc2DT> _o = std::unique_ptr<fb::amrl_msgs::ColoredArc2DT>(new ColoredArc2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ColoredArc2D::UnPackTo(ColoredArc2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = center(); if (_e) _o->center = std::unique_ptr<fb::amrl_msgs::Point2DT>(_e->UnPack(_resolver)); }
  { auto _e = radius(); _o->radius = _e; }
  { auto _e = start_angle(); _o->start_angle = _e; }
  { auto _e = end_angle(); _o->end_angle = _e; }
  { auto _e = color(); _o->color = _e; }
}

inline flatbuffers::Offset<ColoredArc2D> ColoredArc2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ColoredArc2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateColoredArc2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ColoredArc2D> CreateColoredArc2D(flatbuffers::FlatBufferBuilder &_fbb, const ColoredArc2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ColoredArc2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _center = _o->center ? CreatePoint2D(_fbb, _o->center.get(), _rehasher) : 0;
  auto _radius = _o->radius;
  auto _start_angle = _o->start_angle;
  auto _end_angle = _o->end_angle;
  auto _color = _o->color;
  return fb::amrl_msgs::CreateColoredArc2D(
      _fbb,
      ___metadata,
      _center,
      _radius,
      _start_angle,
      _end_angle,
      _color);
}

inline VisualizationMsgT *VisualizationMsg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::VisualizationMsgT> _o = std::unique_ptr<fb::amrl_msgs::VisualizationMsgT>(new VisualizationMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VisualizationMsg::UnPackTo(VisualizationMsgT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = ns(); if (_e) _o->ns = _e->str(); }
  { auto _e = particles(); if (_e) { _o->particles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->particles[_i] = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = path_options(); if (_e) { _o->path_options.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->path_options[_i] = std::unique_ptr<fb::amrl_msgs::PathVisualizationT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->points[_i] = std::unique_ptr<fb::amrl_msgs::ColoredPoint2DT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = lines(); if (_e) { _o->lines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lines[_i] = std::unique_ptr<fb::amrl_msgs::ColoredLine2DT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = arcs(); if (_e) { _o->arcs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->arcs[_i] = std::unique_ptr<fb::amrl_msgs::ColoredArc2DT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<VisualizationMsg> VisualizationMsg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VisualizationMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVisualizationMsg(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsg(flatbuffers::FlatBufferBuilder &_fbb, const VisualizationMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VisualizationMsgT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _ns = _fbb.CreateString(_o->ns);
  auto _particles = _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> (_o->particles.size(), [](size_t i, _VectorArgs *__va) { return CreatePose2Df(*__va->__fbb, __va->__o->particles[i].get(), __va->__rehasher); }, &_va );
  auto _path_options = _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> (_o->path_options.size(), [](size_t i, _VectorArgs *__va) { return CreatePathVisualization(*__va->__fbb, __va->__o->path_options[i].get(), __va->__rehasher); }, &_va );
  auto _points = _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> (_o->points.size(), [](size_t i, _VectorArgs *__va) { return CreateColoredPoint2D(*__va->__fbb, __va->__o->points[i].get(), __va->__rehasher); }, &_va );
  auto _lines = _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> (_o->lines.size(), [](size_t i, _VectorArgs *__va) { return CreateColoredLine2D(*__va->__fbb, __va->__o->lines[i].get(), __va->__rehasher); }, &_va );
  auto _arcs = _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> (_o->arcs.size(), [](size_t i, _VectorArgs *__va) { return CreateColoredArc2D(*__va->__fbb, __va->__o->arcs[i].get(), __va->__rehasher); }, &_va );
  return fb::amrl_msgs::CreateVisualizationMsg(
      _fbb,
      ___metadata,
      _header,
      _ns,
      _particles,
      _path_options,
      _points,
      _lines,
      _arcs);
}

}  // namespace amrl_msgs

namespace sensor_msgs {

inline NavSatStatusT *NavSatStatus::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::NavSatStatusT> _o = std::unique_ptr<fb::sensor_msgs::NavSatStatusT>(new NavSatStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NavSatStatus::UnPackTo(NavSatStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = status(); _o->status = _e; }
  { auto _e = service(); _o->service = _e; }
}

inline flatbuffers::Offset<NavSatStatus> NavSatStatus::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNavSatStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NavSatStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _status = _o->status;
  auto _service = _o->service;
  return fb::sensor_msgs::CreateNavSatStatus(
      _fbb,
      ___metadata,
      _status,
      _service);
}

inline NavSatFixT *NavSatFix::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::NavSatFixT> _o = std::unique_ptr<fb::sensor_msgs::NavSatFixT>(new NavSatFixT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NavSatFix::UnPackTo(NavSatFixT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = status(); if (_e) _o->status = std::unique_ptr<fb::sensor_msgs::NavSatStatusT>(_e->UnPack(_resolver)); }
  { auto _e = latitude(); _o->latitude = _e; }
  { auto _e = longitude(); _o->longitude = _e; }
  { auto _e = altitude(); _o->altitude = _e; }
  { auto _e = position_covariance(); if (_e) { _o->position_covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->position_covariance[_i] = _e->Get(_i); } } }
  { auto _e = position_covariance_type(); _o->position_covariance_type = _e; }
}

inline flatbuffers::Offset<NavSatFix> NavSatFix::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNavSatFix(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NavSatFix> CreateNavSatFix(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NavSatFixT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _status = _o->status ? CreateNavSatStatus(_fbb, _o->status.get(), _rehasher) : 0;
  auto _latitude = _o->latitude;
  auto _longitude = _o->longitude;
  auto _altitude = _o->altitude;
  auto _position_covariance = _fbb.CreateVector(_o->position_covariance);
  auto _position_covariance_type = _o->position_covariance_type;
  return fb::sensor_msgs::CreateNavSatFix(
      _fbb,
      ___metadata,
      _header,
      _status,
      _latitude,
      _longitude,
      _altitude,
      _position_covariance,
      _position_covariance_type);
}

inline LaserScanT *LaserScan::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::LaserScanT> _o = std::unique_ptr<fb::sensor_msgs::LaserScanT>(new LaserScanT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaserScan::UnPackTo(LaserScanT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = angle_min(); _o->angle_min = _e; }
  { auto _e = angle_max(); _o->angle_max = _e; }
  { auto _e = angle_increment(); _o->angle_increment = _e; }
  { auto _e = time_increment(); _o->time_increment = _e; }
  { auto _e = scan_time(); _o->scan_time = _e; }
  { auto _e = range_min(); _o->range_min = _e; }
  { auto _e = range_max(); _o->range_max = _e; }
  { auto _e = ranges(); if (_e) { _o->ranges.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ranges[_i] = _e->Get(_i); } } }
  { auto _e = intensities(); if (_e) { _o->intensities.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->intensities[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<LaserScan> LaserScan::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaserScanT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaserScan(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaserScan> CreateLaserScan(flatbuffers::FlatBufferBuilder &_fbb, const LaserScanT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaserScanT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _angle_min = _o->angle_min;
  auto _angle_max = _o->angle_max;
  auto _angle_increment = _o->angle_increment;
  auto _time_increment = _o->time_increment;
  auto _scan_time = _o->scan_time;
  auto _range_min = _o->range_min;
  auto _range_max = _o->range_max;
  auto _ranges = _fbb.CreateVector(_o->ranges);
  auto _intensities = _fbb.CreateVector(_o->intensities);
  return fb::sensor_msgs::CreateLaserScan(
      _fbb,
      ___metadata,
      _header,
      _angle_min,
      _angle_max,
      _angle_increment,
      _time_increment,
      _scan_time,
      _range_min,
      _range_max,
      _ranges,
      _intensities);
}

inline CompressedImageT *CompressedImage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::CompressedImageT> _o = std::unique_ptr<fb::sensor_msgs::CompressedImageT>(new CompressedImageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CompressedImage::UnPackTo(CompressedImageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = format(); if (_e) _o->format = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<CompressedImage> CompressedImage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CompressedImageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCompressedImage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CompressedImage> CreateCompressedImage(flatbuffers::FlatBufferBuilder &_fbb, const CompressedImageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CompressedImageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _format = _fbb.CreateString(_o->format);
  auto _data = _fbb.CreateVector(_o->data);
  return fb::sensor_msgs::CreateCompressedImage(
      _fbb,
      ___metadata,
      _header,
      _format,
      _data);
}

inline PointFieldT *PointField::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::PointFieldT> _o = std::unique_ptr<fb::sensor_msgs::PointFieldT>(new PointFieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PointField::UnPackTo(PointFieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = datatype(); _o->datatype = _e; }
  { auto _e = count(); _o->count = _e; }
}

inline flatbuffers::Offset<PointField> PointField::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePointField(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PointField> CreatePointField(flatbuffers::FlatBufferBuilder &_fbb, const PointFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PointFieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _name = _fbb.CreateString(_o->name);
  auto _offset = _o->offset;
  auto _datatype = _o->datatype;
  auto _count = _o->count;
  return fb::sensor_msgs::CreatePointField(
      _fbb,
      ___metadata,
      _name,
      _offset,
      _datatype,
      _count);
}

inline PointCloud2T *PointCloud2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::PointCloud2T> _o = std::unique_ptr<fb::sensor_msgs::PointCloud2T>(new PointCloud2T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PointCloud2::UnPackTo(PointCloud2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = height(); _o->height = _e; }
  { auto _e = width(); _o->width = _e; }
  { auto _e = fields(); if (_e) { _o->fields.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fields[_i] = std::unique_ptr<fb::sensor_msgs::PointFieldT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = is_bigendian(); _o->is_bigendian = _e; }
  { auto _e = point_step(); _o->point_step = _e; }
  { auto _e = row_step(); _o->row_step = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
  { auto _e = is_dense(); _o->is_dense = _e; }
}

inline flatbuffers::Offset<PointCloud2> PointCloud2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointCloud2T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePointCloud2(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PointCloud2> CreatePointCloud2(flatbuffers::FlatBufferBuilder &_fbb, const PointCloud2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PointCloud2T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _height = _o->height;
  auto _width = _o->width;
  auto _fields = _fbb.CreateVector<flatbuffers::Offset<fb::sensor_msgs::PointField>> (_o->fields.size(), [](size_t i, _VectorArgs *__va) { return CreatePointField(*__va->__fbb, __va->__o->fields[i].get(), __va->__rehasher); }, &_va );
  auto _is_bigendian = _o->is_bigendian;
  auto _point_step = _o->point_step;
  auto _row_step = _o->row_step;
  auto _data = _fbb.CreateVector(_o->data);
  auto _is_dense = _o->is_dense;
  return fb::sensor_msgs::CreatePointCloud2(
      _fbb,
      ___metadata,
      _header,
      _height,
      _width,
      _fields,
      _is_bigendian,
      _point_step,
      _row_step,
      _data,
      _is_dense);
}

}  // namespace sensor_msgs

namespace geometry_msgs {

inline PointT *Point::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::PointT> _o = std::unique_ptr<fb::geometry_msgs::PointT>(new PointT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Point::UnPackTo(PointT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
}

inline flatbuffers::Offset<Point> Point::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Point> CreatePoint(flatbuffers::FlatBufferBuilder &_fbb, const PointT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PointT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return fb::geometry_msgs::CreatePoint(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z);
}

inline QuaternionT *Quaternion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::QuaternionT> _o = std::unique_ptr<fb::geometry_msgs::QuaternionT>(new QuaternionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Quaternion::UnPackTo(QuaternionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = w(); _o->w = _e; }
}

inline flatbuffers::Offset<Quaternion> Quaternion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuaternion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Quaternion> CreateQuaternion(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuaternionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _w = _o->w;
  return fb::geometry_msgs::CreateQuaternion(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z,
      _w);
}

inline PoseT *Pose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::PoseT> _o = std::unique_ptr<fb::geometry_msgs::PoseT>(new PoseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pose::UnPackTo(PoseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<fb::geometry_msgs::PointT>(_e->UnPack(_resolver)); }
  { auto _e = orientation(); if (_e) _o->orientation = std::unique_ptr<fb::geometry_msgs::QuaternionT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Pose> Pose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pose> CreatePose(flatbuffers::FlatBufferBuilder &_fbb, const PoseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _position = _o->position ? CreatePoint(_fbb, _o->position.get(), _rehasher) : 0;
  auto _orientation = _o->orientation ? CreateQuaternion(_fbb, _o->orientation.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreatePose(
      _fbb,
      ___metadata,
      _position,
      _orientation);
}

inline PoseStampedT *PoseStamped::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::PoseStampedT> _o = std::unique_ptr<fb::geometry_msgs::PoseStampedT>(new PoseStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PoseStamped::UnPackTo(PoseStampedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<PoseStamped> PoseStamped::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoseStamped(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PoseStamped> CreatePoseStamped(flatbuffers::FlatBufferBuilder &_fbb, const PoseStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoseStampedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreatePoseStamped(
      _fbb,
      ___metadata,
      _header,
      _pose);
}

inline PoseWithCovarianceT *PoseWithCovariance::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT> _o = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT>(new PoseWithCovarianceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PoseWithCovariance::UnPackTo(PoseWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<PoseWithCovariance> PoseWithCovariance::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoseWithCovariance(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoseWithCovarianceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _covariance = _fbb.CreateVector(_o->covariance);
  return fb::geometry_msgs::CreatePoseWithCovariance(
      _fbb,
      ___metadata,
      _pose,
      _covariance);
}

inline Vector3T *Vector3::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::Vector3T> _o = std::unique_ptr<fb::geometry_msgs::Vector3T>(new Vector3T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Vector3::UnPackTo(Vector3T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
}

inline flatbuffers::Offset<Vector3> Vector3::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVector3(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Vector3> CreateVector3(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Vector3T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return fb::geometry_msgs::CreateVector3(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z);
}

inline TwistT *Twist::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::TwistT> _o = std::unique_ptr<fb::geometry_msgs::TwistT>(new TwistT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Twist::UnPackTo(TwistT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = linear(); if (_e) _o->linear = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); }
  { auto _e = angular(); if (_e) _o->angular = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Twist> Twist::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTwist(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Twist> CreateTwist(flatbuffers::FlatBufferBuilder &_fbb, const TwistT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TwistT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _linear = _o->linear ? CreateVector3(_fbb, _o->linear.get(), _rehasher) : 0;
  auto _angular = _o->angular ? CreateVector3(_fbb, _o->angular.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateTwist(
      _fbb,
      ___metadata,
      _linear,
      _angular);
}

inline TwistWithCovarianceT *TwistWithCovariance::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT> _o = std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT>(new TwistWithCovarianceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TwistWithCovariance::UnPackTo(TwistWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = twist(); if (_e) _o->twist = std::unique_ptr<fb::geometry_msgs::TwistT>(_e->UnPack(_resolver)); }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<TwistWithCovariance> TwistWithCovariance::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTwistWithCovariance(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TwistWithCovarianceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _twist = _o->twist ? CreateTwist(_fbb, _o->twist.get(), _rehasher) : 0;
  auto _covariance = _fbb.CreateVector(_o->covariance);
  return fb::geometry_msgs::CreateTwistWithCovariance(
      _fbb,
      ___metadata,
      _twist,
      _covariance);
}

}  // namespace geometry_msgs

namespace nav_msgs {

inline OdometryT *Odometry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::nav_msgs::OdometryT> _o = std::unique_ptr<fb::nav_msgs::OdometryT>(new OdometryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Odometry::UnPackTo(OdometryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = child_frame_id(); if (_e) _o->child_frame_id = _e->str(); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT>(_e->UnPack(_resolver)); }
  { auto _e = twist(); if (_e) _o->twist = std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Odometry> Odometry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OdometryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOdometry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Odometry> CreateOdometry(flatbuffers::FlatBufferBuilder &_fbb, const OdometryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OdometryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _child_frame_id = _fbb.CreateString(_o->child_frame_id);
  auto _pose = _o->pose ? CreatePoseWithCovariance(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _twist = _o->twist ? CreateTwistWithCovariance(_fbb, _o->twist.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateOdometry(
      _fbb,
      ___metadata,
      _header,
      _child_frame_id,
      _pose,
      _twist);
}

}  // namespace nav_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_SCHEMA_FB_NAV_MSGS_H_
